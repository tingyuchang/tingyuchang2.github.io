<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Slice 的研究</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="84859a06-6a3d-451a-ace6-40cf9eb8d420" class="page sans"><header><h1 class="page-title"><strong>Slice 的研究</strong></h1></header><div class="page-body"><p id="89252bd4-eea0-4d91-bf29-db5e417cdff9" class="">在 Golang 中，有 Array and Slice 這兩種 type。</p><p id="b70c3a88-960a-4ad3-80cc-97aa24e21f4b" class="">Array 類似其他語言的定義，但是在 Golang 中 Array type 必須定義長度以及元素的類型</p><pre id="fc4bc179-5be4-4f5e-9d3d-1575db35926f" class="code"><code>var a [4]int
a[0] = 1
i := a[0] // i == 1</code></pre><p id="a43b1729-b5de-4017-acbb-92c8f31f74d9" class="">
</p><p id="a2cef2c6-e01c-4dad-a54f-18f305da86a1" class="">Array 的長度是固定的，因此，不同長度的 Array 是不一樣的類型</p><pre id="cbec012d-df72-443b-ac45-198c4b5a6f05" class="code"><code>var a [4]int
var b [5]int
reflect.TypeOf(a) == reflect.TypeOf(b) // false</code></pre><p id="cb5c9c33-08d7-4d75-9fd4-6020ccb6cf56" class="">Array 的定義其實不是這麼好使用，像是在呼叫一個 method 的時候，必須傳入符合其定義的 type ，否則 complier 是不會讓它通過的</p><pre id="e840e310-3fd3-4dc0-a64e-147b36173262" class="code"><code>func sum(arr [10]int) int {}

sum([]int{1,2,3}) 
// cannot use []int{...} (type []int) as type [10]int in argument to sum</code></pre><p id="b366af7e-40c2-4029-a0ef-8f232f6c4979" class="">從以上的範例可以想像，如果我們要計算一個 array 的總和，但限制一定要傳入 10 個元素的陣列，這在使用上是非常不方便的。</p><p id="a9454b91-9d9a-4863-ab83-84418f172306" class="">因此 Golang 提供了另一個在使用上比較方便的類型：<strong>Slice</strong></p><p id="80071e3a-bdba-4c9e-b315-34cd7d141d42" class="">Slice 是一個 struct ，可以看到在 source code 中的定義：</p><pre id="5cce02e1-5f70-49ae-9e66-e516050324fb" class="code"><code>type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}</code></pre><p id="40b9006a-d072-4e7e-847c-b5dd5258cc70" class=""><mark class="highlight-orange">array unsafe.Pointer</mark> 是一個指向 underlying array 內元素的指標，<mark class="highlight-orange">len</mark> 是 slice 的長度，<mark class="highlight-orange">cap</mark> 是從目前 underlying array index 到 array 底的長度，有點難以理解，所以用程式碼說明：</p><pre id="df199025-3b44-4096-b09b-52592ce44930" class="code"><code>a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
// underlying array is [1,2,3,4,5,6,7,8,9]
b := a[3:6] // [3,4,5] len: 3 cap: 7
c := a[3:] // [3,4,5,6,7,8,9] len: 7 cap: 7</code></pre><p id="a417e2e5-4a0d-4597-9d0b-7b680bf7ee91" class="">b 跟 c 都指向同一個 underlying array，b = [3,4,5] c = [3,4,5,6,7,8,9]，len 分別是 3 跟 7 應該沒有問題，而兩者的 cap 都是 7 ，這是因為兩個 slice 都指向 underlying array a 的 <mark class="highlight-orange">index 3</mark>，而 a 的長度是 10，所以 10 - 3 = 7。</p><hr id="a0df34a9-1b5d-4ed3-b622-aececd3aa8cc"/><p id="305a0d77-ee47-4820-873a-d20811ddd5e5" class="">Slice 的說明先到這邊，因為我比較想談的是後面的部分，如果對 Slice 還有基本定義或是使用上的疑慮，可以看官方的<a href="https://blog.golang.org/slices-intro">介紹</a>。</p><p id="12a63594-babb-4314-9b09-fe6fe96826a4" class="">再來談談一些 slice 應用上的可能會有的疑惑</p><pre id="e11d4a5e-af0e-44e4-b35a-0d9c3e47fa77" class="code"><code>a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
b := a[3:6] // [3,4,5] len: 3 cap: 7
c := a[3:] // [3,4,5,6,7,8,9] len: 7 cap: 7

b[3] = 20 // panic: runtime error: index out of range [3] with length 3</code></pre><p id="3da7eac1-e4c6-40e4-aceb-f28f28aba532" class="">雖然 b 的 cap 是 7 ，但是 len 只有 3 因此如果直接 assign [3] 會造成 panic error。那麼我們要怎麼擴充 b 呢？有三個方法： <mark class="highlight-orange">append</mark>, <mark class="highlight-orange">copy</mark> and <mark class="highlight-orange">re-slice (if capacity is enough)</mark></p><pre id="4bfb4a7e-5d25-41a0-9047-ac816c03bc5b" class="code"><code>// append
b = append(b, item)

//copy

b2 := make([]int, len(b)+1)
copy(b2. b)
b2[len(b)] = item

//re-slice, attention! not over the capacity of b
b = [:len(b)+1]
b[len(b)] = item</code></pre><p id="dbbdcfd9-b933-40ff-b689-dce9c66b2e1f" class="">append 比較簡單也常用。copy 要注意到 underlying array 是不同的，在某些情況下，使用 copy 來 insert 會比 append 來得有效率 (<a href="https://github.com/golang/go/wiki/SliceTricks">slice tricks</a> 中有提到，之後會再說明)。re-slice 也很直覺易懂，不過要注意到 capacity 是否足夠，否則是會產生 runtime error 的。</p><p id="c5935c04-ffdc-4cae-a697-489e12b1a6f4" class="">值得一提的是使用 append or re-slice 要注意到 b 的 underlying array 也會被修改這一點</p><pre id="1aee3655-7c99-4ee3-87e6-6d0a5ac98681" class="code"><code>b = append(b, 20)

// b = [3,4,5,20]

// c = [3,4,5,20,7,8,9]

// a = [0,1,2,3,4,5,20.7,8,9]</code></pre><p id="7530974c-1bd5-4087-bb73-a093d696d8f9" class="">在 underlying array 有足夠的 capacity 下，會將新的元素放進去，因此 underlying array 中的元素就會被置換，連帶影響到其他指向這個 array 的 slices，想是 c[3] 就變成了 20。</p><p id="23058227-7c63-431b-bc6f-3c3bfb58cf64" class="">但如果 underlying array 沒有足夠的 capacity 呢？ 請大家再看一段程式碼：</p><pre id="4c66541f-5cc6-4b04-be85-fa96dbbfeb69" class="code"><code>c = append(c, 20)
// [3,4,5,6,7,8,9,20]
b = b[:cap(b)]
// [3,4,5,6,7,8,9]</code></pre><p id="c6259415-9914-436c-9a40-be6b08b09fd9" class="">為什麼 b 跟 c 的行為不一樣了呢？這是因為 c 的 append 發現 c 的 capacity 不夠了，因此觸發了</p><p id="eac12620-9795-4b92-9b4e-2237b3636329" class=""><mark class="highlight-orange">growslice</mark> 這一個 func ，重新產生了一組新的 underlying array 給他，這個時候 b, c 兩者的 underlying array 已經不同了。</p><p id="e113fe78-1216-4fd4-8161-d1239c3df10f" class="">其中運作的原理，可以看看 <a href="https://github.com/golang/go/blob/4bb0847b088eb3eb6122a18a87e1ca7756281dcc/src/runtime/slice.go#L162">growslice</a> 這一段 source code </p><hr id="e3ecdd55-c9e0-4a12-ab19-bbc6b34bd818"/><pre id="e01d622c-cf42-48d3-9ad3-04064cf10a83" class="code"><code>// growslice handles slice growth during append.
// It is passed the slice element type, the old slice, and the desired new minimum capacity,
// and it returns a new slice with at least that capacity, with the old data
// copied into it.</code></pre><p id="7f4ca278-c5c2-46ad-b9d8-096181c9dbd6" class="">
</p><p id="65c467b2-7e1a-4416-ad25-c0fe5043b44f" class="">當 slice 的 cap 不足需要擴大的時候，就會呼叫 growslice 這一個 func 處理，會先根據 old. cap (old.cap) 以及 exp.cap 來計算出 new.cap。處理的邏輯如下: (old.cap ⇒ 舊的 exp.cap ⇒ 期望的 new.cap ⇒ 最後計算出來新的)</p><ol type="1" id="92b6c9f7-73b1-436a-b78d-ebb32230bf8a" class="numbered-list" start="1"><li>如果 exp.cap 大於兩倍的 old.cap，new.cap = exp.cap</li></ol><ol type="1" id="37bc661e-0630-4f13-963b-a7f31e3e19a1" class="numbered-list" start="2"><li>如果 exp.cap 小於兩倍的 old.cap，而且 old.cap &lt; 1024，那麼 new.cap 就等於兩倍的 old.cap</li></ol><ol type="1" id="cd8c97d7-f9e7-4767-8db5-b813e7e0b93f" class="numbered-list" start="3"><li>如果 exp.cap 小於兩倍的 old.cap，但是 old.cap ≥ 1024，那麼就會跑一個 for loop 讓 new.cap = 1.25 old.cap ，直到 new.cap ≥ exp.cap</li></ol><ol type="1" id="a92c4cc9-bad5-45bb-a23a-6dee1bc3ea0e" class="numbered-list" start="4"><li>最後，如果 old.cap ≤ 0, new.cap = exp.cap</li></ol><p id="d6c5ef50-0c30-44da-81b2-0e8984343517" class="">計算完新的 cap 之後，就會把目前 array 內的元素<mark class="highlight-orange">複製到新的 array 中</mark></p><p id="05fe6709-6084-44cc-82a1-61ef431b7ad2" class="">
</p><p id="3eca925b-7f0c-4ea4-9b94-448051ba0fa7" class="">接下來談談 slice 中傳遞資料的問題</p><h2 id="f4de38aa-1aba-4597-8555-abe51cfcef45" class="">Call by Value</h2><pre id="3af176f8-d067-4252-a737-4ac6c1be3a55" class="code"><code>func main() {
	a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

	b := a[3:6]
	c := a[3:]
	double(b)
	fmt.Println(b) // [6 8 10]
	fmt.Println(c) // [6 8 10 6 7 8 9]
}
func double(x []int) {
	for i, v := range x {
		x[i] = v * 2
	}
}</code></pre><p id="24e3cfa8-bca4-4f3b-a70a-8f0179ed3316" class="">在 Golang 的世界裡面只要沒有用到指標，就都是 call by value ，slice 也不例外，但是為什麼上面的程式碼 double 卻會影響到 c 呢？這是因為在傳遞 b 給 double 的時候，的確是複製了一份 b 的值，但是 b 的 slice (struct) 只有 ptr, len 以及 cap ，並沒有真正的持有元素，而複製出來的 slice 也指向了同樣的 underlying array ，所以在 double 裡面修改了元素，就會影響到 c。 </p><p id="ceb22300-76f3-4d93-a415-0cbb20751ad9" class="">要利用這個特性時，必須要注意到改變 slice 的長度時 (append, re-slice or copy) 都會讓 slice 的 underlying array 變成新的，因此可能就會發生在新的 slice 中修改，但是其他地方的 slice 因為兩者的 underlying array 不一樣了，造成修改是無效的，要怎麼有效的處理這個情況發生呢？可以參考以下的思考：</p><ol type="1" id="ee1444c8-7dc9-4687-9080-7610b1fca2cc" class="numbered-list" start="1"><li>避免改變 slice ，當 slice 被當作參數傳遞之後，不嘗試做任何 len or cap 的修改，不讓 realloc 的情況發生，也許有人會認為只要熟悉 slice 的原理，小心操作就不會有這個問題產生，但是你要怎麼保證其他人不會踩到這個陷阱呢？請思考以下的程式碼：<pre id="567adc39-1207-4c53-9039-85ba7fb49852" class="code"><code>// 這個例子是要證明操作 append 的先後順序，其實對外面的 xs 影響極大
// 先進行 append 的話，造成 alloc new underlying array，之後再對 xs2 進行的操作
// 就跟外面的 xs 無關了。反過來，如果先進行操作，再進行 append ，那麼
//  xs2[0] = 1
//  xs2[1] = 2
// 這兩個都會影響到原本的 xs ，因為這時候 xs &amp; xs2 都還是同一個 underlying array
func main() {
	xs := make([]int, 1, 3)
	func(xs2 []int) {
	    xs2 = xs2[1:3]
	    // xs2 = append(xs2, 3)
			xs2[0] = 1
	    xs2[1] = 2
	    xs2 = append(xs2, 3)
		fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, xs2, &amp;xs2)		
	}(xs)
	xs = xs[:cap(xs)]
	fmt.Printf(&quot;Outside: %v Addr of slice: %p\n&quot;, xs, &amp;xs)
}</code></pre><p id="eef741d0-16b6-4e8b-8711-0d95a97bc614" class="">看過了上面的例子就知道，這樣的錯誤要 debug 是極為困難的。</p><p id="3355e74b-2950-42a0-ab2d-3f721e38009e" class="">函式的撰寫者無法限制 capacity ，因此即使他知道可能會有 realloc slice 的情況產生了，也無法阻止。</p></li></ol><ol type="1" id="f8b42a13-ed46-44ab-8cce-ed4d03ddbb03" class="numbered-list" start="2"><li>會需要改變 slice 長度的操作，不要依賴既有的 slice，建立一個新的 slice ，以及使用新的 slice 當作返回結果，感覺對於記憶體的使用上比較沒有效率，但是比起誤用造成的問題，應該是兩權相害取其輕，否則就需要更嚴格的規範使用的情境。<pre id="9c73c63e-f665-4499-9bd3-fc19e3752767" class="code"><code>func Insert(x []interface{}, index int, items ...interface{}) []interface{} {
	return append(x[:index], append(items, x[index:]...)...)
}

func InsertByCopy(x []interface{}, index int, item interface{}) []interface{} {
	s := append(x, 0)
	copy(s[index+1:], s[index:])
	s[index] = item
	return s
}</code></pre></li></ol><ol type="1" id="a54390d9-4e40-4d45-b6aa-7d4e0ed1d55e" class="numbered-list" start="3"><li>如果是要處理 Slice of Structs  的時候，可以嘗試使用 Slice of Pointers ，也就是只傳遞指標，而不是數據本身，如此一來即使 underlying array 的元素被複製了，也還是指向相同的數據，不過這個作法有好也有壞，稍後的章節會深入討論。</li></ol><h2 id="d85c5d9a-1991-4e98-b67c-ecaae4eef548" class="">Slice of pointers vs Slice of structs</h2><p id="16d13680-6943-4345-8ef3-3f3eb50ce31b" class="">先來複習一下幾個 slice 使用上的情境</p><p id="3b8f86df-db32-41da-a5d4-574b08f4681a" class=""><strong>Example 1</strong></p><pre id="848d8989-58ac-48a8-8a4d-a3b014782607" class="code"><code>// xs 被當作參數傳遞進去，裡面的 xs2 跟外面的 xs 其實是不同的
// 不過因為 underlying array 一樣，所以 xs2[0] = 1 
// 也讓外面的 xs 受到影響
func main() {
	xs := make([]int, 1, 3)

	func(xs2 []int) {
		xs2[0] = 1
		fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, xs2, &amp;xs2)
		// Inside: [1] Addr of slice: 0xc0000b6030
	}(xs)

	fmt.Printf(&quot;Outside: %v Addr of slice: %p\n&quot;, xs, &amp;xs)
	// Outside: [1] Addr of slice: 0xc0000b6018
}</code></pre><p id="d8516a64-595d-4fee-9b1a-14aec799e67f" class=""><strong>Example 2</strong></p><pre id="ec499f27-01db-4966-b127-540bc10c42b1" class="code"><code>// 這個例子就可以很明顯的知道，當 append 啟動的時候，
// 因為增加三個元素後，已經超過原本 slice 的 capacity
// 所以 xs2 會呼叫 growslice 建立新的 underlying array ，並把當前的元素複製過去
// 這個時候 xs 與 xs2 已經是參考到不同的 underlying array
func main() {
	xs := make([]int, 1, 3)

	func(xs2 []int) {
	    xs2 = append(xs2, 1,2,3)
	    xs2[0] = 99
			fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, xs2, &amp;xs2)
			// Inside: [99 1 2 3] Addr of slice: 0xc00010c018
	}(xs)

	fmt.Printf(&quot;Outside: %v Addr of slice: %p\n&quot;, xs, &amp;xs)
	// Outside: [0] Addr of slice: 0xc00010c000

}</code></pre><p id="e1ff9c21-e9db-49a1-b5b9-c373d5416768" class="">example 1 說明了只要 underlying array 是一樣的，即使 slice 是不一樣的，也不會有什麼問題</p><p id="a8f18ed4-5939-4264-858d-1d459025c6f1" class="">example2 則是改變了 underlying array ，因此讓兩個 slices 彼此的行為脫鉤，不再互相影響</p><p id="ca4119c1-4169-4838-acc7-cbb6305e0b59" class="">
</p><p id="9fb080b8-6498-4212-be47-2e2cb18d5a2a" class="">以下來看看 struct 在 slice 中要注意的地方</p><pre id="b908dcf9-15b8-4776-860b-c13b7debae07" class="code"><code>type Object struct {
	Value int
}

func main() {
    xo := []Object{
            Object{0}, Object{1}, Object{2}, Object{3}, 
        }
    obj1 := xo[0]
    obj1.Value = 21
    fmt.Println(xo) // [{0} {1} {2} {3}]

		fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, obj1, &amp;obj1)
    fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, xo[0], &amp;xo[0])
}</code></pre><p id="2112e13b-200d-4798-ad04-fe5c79e51112" class="">這個問題很簡單，因為 Golang 是 call by value ，所以 <mark class="highlight-orange">obj1 := xo[0]</mark> 是複製 xo[0] 的資料給 obj1，所以兩個的 ptr 也不同，改成以下的寫法即可</p><pre id="b3c27834-6273-4969-83ac-18448be610b3" class="code"><code>// 使用指標
obj2 := &amp;xo[1]
obj2.Value = 22
fmt.Println(xo) // [{0} {22} {2} {3}]

// 用 index 也可以
xo[2].Value = 23
fmt.Println(xo) // [{0} {22} {23} {3}]</code></pre><p id="8bfe45e2-c671-40d4-92cb-b637b6155c99" class="">
</p><p id="78176c04-9c2b-4306-a900-af0679e1e5a8" class="">在 slice 中使用 struct 要特別注意的地方大概是這樣。接著我們回到這一個章節的主題：<strong>Slice of Pointers</strong></p><p id="d0a3da1b-8025-4f50-8dcc-adeb087912ca" class="">當 slice 改變時候，裡面的 struct 也會被複製一份到新的 underlying array ，所以既使用了 &amp;xo[0] 的指標也沒用，因為新的 slice 裡面的 struct 跟舊的是不同的</p><pre id="0a71a009-f7ea-4f69-aab0-8e63f0feaf37" class="code"><code>xo := []Object{
		Object{0}, Object{1}, Object{2}, Object{3},
}

obj1 := &amp;xo[0]
xo = append(xo, Object{4})
obj1.Value = 21

fmt.Println(xo) // [{0} {1} {2} {3} {4}]
fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, obj1, &amp;obj1)
// Inside: &amp;{21} Addr of slice: 0xc000102018
fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, xo[0], &amp;xo[0])
// Inside: {0} Addr of slice: 0xc000116000</code></pre><p id="ab3c9109-bc69-4b4b-a2ca-e385f4988185" class="">要怎麼解決這個問題呢？答案就是利用 Slice of Pointers，指標被複製了也沒關係，它們還是指向同一個 struct。</p><pre id="2f77c649-f623-480a-aeda-6458767b7413" class="code"><code>xop := []*Object{
		&amp;Object{0}, &amp;Object{1}, &amp;Object{2}, &amp;Object{3},
}

obj2 := xop[0]
xop = append(xop, &amp;Object{4})
obj2.Value = 21

fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, obj2, obj2)
// Inside: &amp;{21} Addr of slice: 0xc000018050
fmt.Printf(&quot;Inside: %v Addr of slice: %p\n&quot;, xop[0], xop[0])
// Inside: &amp;{21} Addr of slice: 0xc000018050</code></pre><p id="da9d2bdf-d167-4909-90a3-4d06ee7c5299" class="">
</p><p id="5f1a61ee-244d-45b9-861a-9a798fb3ffc6" class=""><a href="https://github.com/kubernetes/apimachinery/blob/a644435e2c133d990b624858d9c01985d7f59adf/pkg/runtime/conversion.go#L56">Kubernetes </a>的 API 也運用了同樣的操作 ，不是直接拿 in []string ，而是指標，避免 in []string 被修改，而沒有反應在複製的參數中。</p><pre id="dad1382d-b08a-462b-8dab-6ad86e6c30d1" class="code"><code>func Convert_Slice_string_To_string(in *[]string, out *string, s conversion.Scope) error {
	if len(*in) == 0 {
		*out = &quot;&quot;
		return nil
	}
	*out = (*in)[0]
	return nil
}</code></pre><p id="9bbb8612-a610-4236-b8de-4905b3b6645d" class="">
</p><p id="eb299c86-84ca-4d8b-9d26-d55f7b9d44f9" class="">最後要注意使用在 struct slice 中，使用 Slice of Pointers 會比 Slice of Structs 的效率以及空間的使用上都會比較多一些，原因也很簡單，Slice of Pointers 比 Slice of Structs 還多了指標的建立以及儲存，所以如果你對於 Slice 內資料的一致性沒有這麼大的需求，其實改用 Slice of Struct ，以及要存取的時候，利用 index 來操作 struct 就好了，沒有必要一定要建立整個 Slice of Pointers。</p><p id="17e01088-4eef-4c7a-bdda-061c5d21d6bd" class="">恩... 可以看到其實差別還蠻大的</p><pre id="c2c879d0-13fe-485a-b660-777842dbb604" class="code"><code>type Object struct {
	Value int
}

func BenchmarkWithPointer(b *testing.B) {
	b.ReportAllocs()

	for i := 0; i &lt; b.N; i++ {
		xo := make([]*Object, 100)
		for i:=0; i&lt;100; i++ {
			xo = append(xo, &amp;Object{i})
		}
	}
}

func BenchmarkWithoutPointer(b *testing.B) {
	b.ReportAllocs()

	for i := 0; i &lt; b.N; i++ {
		xo := make([]Object, 100)
		for i:=0; i&lt;100; i++ {
			xo = append(xo, Object{i})
		}
	}
}

// BenchmarkWithPointer-8      507992	   2068 ns/op	  2592 B/op	 101 allocs/op
// BenchmarkWithoutPointer-8   3619908  370.8 ns/op	  1792 B/op	   1 allocs/op</code></pre><p id="4603d9a2-a345-4ecd-98e3-1127f61fcb95" class="">BTW: 這裡提到的使用 Slice of Struct 比較好跟 <a href="https://golang.org/doc/faq#methods_on_values_or_pointers">Struct Method 使用 Pointer 比較好</a>是不同的概念</p><p id="ec5c9605-4bcc-4027-8863-34f39723babf" class="">
</p><h3 id="7ad5b003-958c-4d8a-8c74-c4620a05284c" class="">Insert: Append vs Copy</h3><p id="41d6fefb-ed84-4b9a-9178-7c7d2a657944" class="">上面有提到在 slice 中 insert 元素，有的時候 copy 會比 append 來得有效率，這其實是出自 <a href="https://github.com/golang/go/wiki/SliceTricks">SliceTricks</a> 中的一段解釋:</p><pre id="90be469b-4d0f-4f6c-ba58-ffc562945576" class="code"><code>a = append(a[:i], append(b, a[i:]...)...)

// The above one-line way copies a[i:] twice and
// allocates at least once.
// The following verbose way only copies elements
// in a[i:] once and allocates at most once.
// But, as of Go toolchain 1.16, due to lacking of
// optimizations to avoid elements clearing in the
// &quot;make&quot; call, the verbose way is not always faster.
//
// Future compiler optimizations might implement
// both in the most efficient ways.
//
// Assume element type is int.
func Insert(s []int, k int, vs ...int) []int {
	if n := len(s) + len(vs); n &lt;= cap(s) {
		s2 := s[:n]
		copy(s2[k+len(vs):], s[k:])
		copy(s2[k:], vs)
		return s2
	}
	s2 := make([]int, len(s) + len(vs))
	copy(s2, s[:k])
	copy(s2[k:], vs)
	copy(s2[k+len(vs):], s[k:])
	return s2
}

a = Insert(a, i, b...)</code></pre><p id="7131491d-3d4e-44f4-a0f2-fbc850731a1f" class="">append 觸發了兩次的 realloc ，而 copy  只有在 cap 不足，重新宣告 s2 的時候做了一次，如果 capacity 是夠了，那麼連一次的 realloc 都沒做</p><pre id="bd963c73-c972-4d2b-8f3d-bada127d0a36" class="code"><code>BenchmarkInsertByAppend-8   	 3905568	       295.0 ns/op	     672 B/op	       2 allocs/op
BenchmarkInsertByCopy-8     	 7681284	       156.8 ns/op	     352 B/op	       1 allocs/op</code></pre><h3 id="5ec4f366-a350-434e-b48e-f95d4b8a2d64" class="">結論：（寫在最後面就是希望不要只看結論，要看程式碼去理解）</h3><ol type="1" id="bc464923-88b6-43bf-b998-0f2ace4964e8" class="numbered-list" start="1"><li>使用 slice 的時候，必須充分理解跟 underlying array 之間的關係，slice 不持有元素，只持有指標</li></ol><ol type="1" id="4ea8ae35-ae77-42b7-981f-7116ee8d333e" class="numbered-list" start="2"><li>Append, copy 都可能會改變 slice 的 capacity 導致 realloc ，re-slice 只能改變 length of slice </li></ol><ol type="1" id="c59f6d8a-cd3d-4e53-aa2f-1c4e9b3d0e4a" class="numbered-list" start="3"><li>一旦發生了 slice realloc ，就會把現有的 underlying array 的資料複製到新的 underlying array </li></ol><ol type="1" id="ba8278e1-56fc-460a-94c7-996855c42fd1" class="numbered-list" start="4"><li>在 slice 中使用 pointer  ([]*Object)是個好方法，但是要注意在 struct of slice 上其效能的消耗</li></ol><ol type="1" id="3b665e85-b8ff-40b6-8066-ad6f8fc72095" class="numbered-list" start="5"><li>直接傳遞 slice 的指標 (*[]Object) 也是不錯，可以參考 k8s 的做法</li></ol><ol type="1" id="9cf40d2d-421f-40c4-a6cf-1f193de30a6c" class="numbered-list" start="6"><li>Copy 處理得好，會比 Append 來得有效率 </li></ol><h3 id="c29a4311-1e43-4e40-b25d-b885759f73c4" class="">Reference</h3><ul id="2a3a321e-288d-46e7-bca7-21020a44d32c" class="bulleted-list"><li>https://blog.golang.org/slices-intro</li></ul><ul id="49a4c93a-131d-49c0-8a80-e10997faf915" class="bulleted-list"><li><a href="https://github.com/golang/go/wiki/SliceTricks">https://github.com/golang/go/wiki/SliceTricks</a></li></ul><ul id="e600e7af-c3d6-4ce1-aece-d0c8d1848307" class="bulleted-list"><li><a href="https://medium.com/swlh/golang-tips-why-pointers-to-slices-are-useful-and-how-ignoring-them-can-lead-to-tricky-bugs-cac90f72e77b">https://medium.com/swlh/golang-tips-why-pointers-to-slices-are-useful-and-how-ignoring-them-can-lead-to-tricky-bugs-cac90f72e77b</a></li></ul><ul id="3b5b7463-a100-4dd7-b087-472c838e1524" class="bulleted-list"><li><a href="https://medium.com/@opto_ej/there-are-other-nuances-one-should-consider-c798f12be15c">https://medium.com/@opto_ej/there-are-other-nuances-one-should-consider-c798f12be15c</a></li></ul><ul id="66608abe-db2d-48a5-8f86-1d47df705438" class="bulleted-list"><li><a href="https://philpearl.github.io/post/bad_go_slice_of_pointers/">https://philpearl.github.io/post/bad_go_slice_of_pointers/</a></li></ul><p id="e970bab0-2b2c-4204-b151-f2d07fda8cc2" class="">
</p></div></article></body></html>